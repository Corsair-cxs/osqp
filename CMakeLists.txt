cmake_minimum_required(VERSION 3.16)
project(osqp)

set(CMAKE_BUILD_TYPE Debug)
set(CMAKE_VERBOSE_MAKEFILE ON)

include(GNUInstallDirs)
include(CMakeDependentOption)
include(CMakePackageConfigHelpers)

# Detect operating system
# ----------------------------------------------
message(STATUS "We are on a ${CMAKE_SYSTEM_NAME} system")
if(${CMAKE_SYSTEM_NAME} STREQUAL "Linux")
  set(IS_LINUX ON)
elseif(${CMAKE_SYSTEM_NAME} STREQUAL "Darwin")
  set(IS_MAC ON)
elseif(${CMAKE_SYSTEM_NAME} STREQUAL "Windows")
  set(IS_WINDOWS ON)
endif()

# OSQP Versioning
# ----------------------------------------------
set(OSQP_VERSION
    "0.0.0"
    CACHE STRING "The version number of OSQP")
if(NOT OSQP_VERSION STREQUAL "0.0.0")
  configure_file("${PROJECT_SOURCE_DIR}/configure/version.h.in" "${PROJECT_SOURCE_DIR}/include/private/version.h")
endif()

# Conda environment detection
# ----------------------------------------------
# If MKL_ROOT is not explicitly set, and we're running inside a conda environment, set MKL_ROOT to $CONDA_PREFIX to see
# if we can find MKL (if installed through `conda install -c intel mkl-devel`) On a typical OneAPI installation outside
# conda, this would mean specifying: -DMKL_DIR=/path/to/oneapi/mkl/latest/lib/cmake/mkl
# -DMKL_ROOT=/path/to/oneapi/mkl/latest
# ----------------------------------------------
if(NOT DEFINED ENV{MKL_ROOT})
  if(DEFINED ENV{CONDA_PREFIX})
    message(STATUS "Detected Conda environment - setting MKL_ROOT to $CONDA_PREFIX")
    set(MKL_ROOT $ENV{CONDA_PREFIX})
    include_directories("$ENV{CONDA_PREFIX}/include")
    link_directories("$ENV{CONDA_PREFIX}/lib")
  endif()
endif()

set(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/out)
set(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/out)

# Prevent generation of output Debug/ folder on MSVC See https://stackoverflow.com/questions/543203
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG "${EXECUTABLE_OUTPUT_PATH}")
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE "${EXECUTABLE_OUTPUT_PATH}")
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_DEBUG "${LIBRARY_OUTPUT_PATH}")
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_RELEASE "${LIBRARY_OUTPUT_PATH}")

# Some non-standard CMake modules
list(APPEND CMAKE_PREFIX_PATH ${PROJECT_SOURCE_DIR}/configure/cmake)
list(APPEND CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/configure/cmake)
include(Utils)

# Set options
# ----------------------------------------------
option(OSQP_BUILD_SHARED_LIB "Build the shared library" ON)
option(OSQP_BUILD_STATIC_LIB "Build the static library" ON)

cmake_dependent_option( OSQP_BUILD_DEMO_EXE
                        "Build the demo executable (requires the static library)"
                        ON    # Default to on
                        OSQP_BUILD_STATIC_LIB OFF ) # Force off if the static library isn't built

set(ALGEBRA
    "default"
    CACHE STRING "The Algebra to use (default/mkl/cuda)")

option(PRINTING "Enable solver printing" ON)
option(PROFILING "Enable solver profiling (timing)" ON)
option(CTRLC "Enable user interrupt (Ctrl-C)" ON)

# Is the code generated for embedded platforms? 1 :   Yes. Matrix update not allowed. 2 :   No. Matrix update allowed.
if(DEFINED EMBEDDED)
  message(STATUS "Forcing ALGEBRA=default for EMBEDDED mode")
  set(ALGEBRA "default")
  message(STATUS "Disabling printing/profiling/Ctrl-C for EMBEDDED mode")
  set(PRINTING OFF)
  set(PROFILING OFF)
  set(CTRLC OFF)

  # Disable shared library and demo exe on embedded applications
  set(OSQP_BUILD_SHARED_LIB OFF)
  set(OSQP_BUILD_DEMO_EXE OFF)

  message(STATUS "EMBEDDED = ${EMBEDDED}")
else()
  message(STATUS "EMBEDDED = OFF")
endif()

# Display final CTRLC behaviour
message(STATUS "CTRLC = ${CTRLC}")

# Display final ALGEBRA chosen and set internal boolean variables
message(STATUS "ALGEBRA = ${ALGEBRA}")
if(${ALGEBRA} STREQUAL "default")
  set(ALGEBRA_DEFAULT ON)
elseif(${ALGEBRA} STREQUAL "mkl")
  set(ALGEBRA_MKL ON)
elseif(${ALGEBRA} STREQUAL "cuda")
  set(ALGEBRA_CUDA ON)
endif()

if(ALGEBRA_CUDA)
  option(DFLOAT "Use floats instead of doubles" ON)
else()
  option(DFLOAT "Use floats instead of doubles" OFF)
endif()

if(DFLOAT AND ALGEBRA_MKL)
  message(STATUS "Disabling DFLOAT for MKL (Intel RCI ISS does not support single-precision values yet.)")
  set(DFLOAT OFF)
endif()
message(STATUS "DFLOAT = ${DFLOAT}")

option(DLONG "Use long integers (64bit) for indexing" ON)
if(NOT (CMAKE_SIZEOF_VOID_P EQUAL 8))
  message(STATUS "Disabling long integers (64bit) on 32bit machine")
  set(DLONG OFF)
elseif(ALGEBRA_CUDA)
  message(STATUS "Disabling long integers (64bit) for CUDA")
  set(DLONG OFF)
endif()
message(STATUS "DLONG = ${DLONG}")

option(DEBUG "Debug mode" OFF)
if(CMAKE_BUILD_TYPE STREQUAL "Debug")
  set(DEBUG ON)
endif()
message(STATUS "DEBUG = ${DEBUG}")

if(DEBUG)
  set(CMAKE_VERBOSE_MAKEFILE ON)
  set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
endif()

option(COVERAGE "Perform code coverage" OFF)
message(STATUS "COVERAGE = ${COVERAGE}")

if(OSQP_CUSTOM_MEMORY)
  message(STATUS "User custom memory management header: ${OSQP_CUSTOM_MEMORY}")
endif()

# Rename compile-time constants & configure
# ----------------------------------------------
# If we are creating any OSQP_* compile-time constants from CMake variables, do so here.
set(OSQP_ALGEBRA ${ALGEBRA})

configure_file(${CMAKE_CURRENT_SOURCE_DIR}/configure/osqp_configure.h.in
               ${CMAKE_CURRENT_BINARY_DIR}/include/public/osqp_configure.h NEWLINE_STYLE LF)


if(OSQP_CUSTOM_MEMORY)
  message(STATUS "Using custom memory management header: ${OSQP_CUSTOM_MEMORY}")
endif()

# Configure support for custom memory allocators
configure_file(${CMAKE_CURRENT_SOURCE_DIR}/configure/custom_headers/memory_defs.h.in
               ${CMAKE_CURRENT_BINARY_DIR}/include/private/memory_defs.h NEWLINE_STYLE LF)

if(OSQP_CUSTOM_PRINTING)
  message(STATUS "Using custom printing header: ${OSQP_CUSTOM_PRINTING}")
endif()

# Configure support for custom printing functions
configure_file(${CMAKE_CURRENT_SOURCE_DIR}/configure/custom_headers/print_defs.h.in
               ${CMAKE_CURRENT_BINARY_DIR}/include/private/print_defs.h NEWLINE_STYLE LF)

# CUDA support
# ----------------------------------------------
if(ALGEBRA_CUDA)
  enable_language(CUDA)
  find_package(CUDA)

  # cublas and cusparse headers
  include_directories(${CMAKE_CUDA_TOOLKIT_INCLUDE_DIRECTORIES})

  # sm_75 -> Turing support
  if(DFLOAT)
    set(CMAKE_CUDA_ARCHITECTURES 52 75)
    # set(CMAKE_CUDA_FLAGS "${CMAKE_CUDA_FLAGS} --gpu-architecture=compute_52 --gpu-code=sm_52,sm_75")
  else()
    # To use doubles we need compute capability 6.0 for atomic operations
    set(CMAKE_CUDA_ARCHITECTURES 60 75)
    # set(CMAKE_CUDA_FLAGS "${CMAKE_CUDA_FLAGS} --gpu-architecture=compute_60 --gpu-code=sm_60,sm_75")
  endif()
endif()


# Set Compiler flags
# ----------------------------------------------
set(CMAKE_POSITION_INDEPENDENT_CODE ON) # -fPIC

if(NOT MSVC)
  if(COVERAGE)
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} --coverage")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} --coverage")
    if(FORTRAN)
      set(CMAKE_FORTRAN_FLAGS "${CMAKE_FORTRAN_FLAGS} --coverage")
    endif(FORTRAN)
  endif()

  if(DEBUG)
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -O0 -g")
  else()
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -O3")
  endif()

  set(CMAKE_C_STANDARD_LIBRARIES "${CMAKE_C_STANDARD_LIBRARIES} -lm") # Include math
  # Include real time library in linux
  if(IS_LINUX)
    set(CMAKE_C_STANDARD_LIBRARIES "${CMAKE_C_STANDARD_LIBRARIES} -lrt -ldl")
  endif()
endif(NOT MSVC)

# ----------------------------------------------
# OSQPLIB
# ----------------------------------------------
add_library(OSQPLIB OBJECT "")

add_subdirectory(include)
add_subdirectory(src)
add_subdirectory(algebra)

get_property(
  osqplib_includes
  TARGET OSQPLIB
  PROPERTY INCLUDE_DIRECTORIES)
get_property(
  osqplib_sources
  TARGET OSQPLIB
  PROPERTY SOURCES)

# ----------------------------------------------
# Language-specific compilation checks
# ----------------------------------------------
if(PYTHON)
  if(NOT PYTHON_INCLUDE_DIRS)
    message(FATAL_ERROR "You need Python include directories to build the Python interface")
  endif(NOT PYTHON_INCLUDE_DIRS)

  include_directories(${PYTHON_INCLUDE_DIRS})
  add_definitions(-DPYTHON)

  if(BUILD_TESTING)
    message(STATUS "Disabling BUILD_TESTING because we are building Python interface")
    set(BUILD_TESTING OFF)
  endif(BUILD_TESTING)
endif(PYTHON)

if(MATLAB)
  find_package(Matlab)
  if(NOT Matlab_FOUND)
    message(FATAL_ERROR "You need Matlab libraries to build the Matlab interface")
  endif(NOT Matlab_FOUND)
  message(STATUS "Matlab root is " ${Matlab_ROOT_DIR})

  include_directories(${Matlab_INCLUDE_DIRS})
  add_definitions(-DMATLAB)

  # Insist on the pre 2018 complex data API so that mxGetPr will work correctly
  add_definitions(-DMATLAB_MEXSRC_RELEASE=R2017b)
  message(STATUS "Using Matlab pre-2018a API for mxGetPr compatibility")

  if(BUILD_TESTING)
    message(STATUS "Disabling BUILD_TESTING because we are building Matlab interface")
    set(BUILD_TESTING OFF)
  endif(BUILD_TESTING)
endif(MATLAB)

if(R_LANG)
  find_package(R)
  if(NOT R_FOUND)
    message(FATAL_ERROR "You need R libraries to build the R interface")
  endif(NOT R_FOUND)

  message(STATUS "R exec is: " ${R_EXEC})
  message(STATUS "R root dir is: " ${R_ROOT_DIR})
  message(STATUS "R includes are in: " ${R_INCLUDE_DIRS})

  include_directories(${R_INCLUDE_DIRS})
  add_definitions(-DR_LANG)

  if(BUILD_TESTING)
    message(STATUS "Disabling UNITTESTS because we are building the R interface")
    set(BUILD_TESTING OFF)
  endif(BUILD_TESTING)
endif(R_LANG)

if(PYTHON OR MATLAB OR R_LANG)
  # Disable shared library and demo exe when building the interfaces
  set(OSQP_BUILD_SHARED_LIB OFF)
  set(OSQP_BUILD_DEMO_EXE OFF)
endif()

# ----------------------------------------------
# Static Library - osqpstatic
# ----------------------------------------------
if( OSQP_BUILD_STATIC_LIB )
  add_library(osqpstatic STATIC $<TARGET_OBJECTS:OSQPLIB>)
  set_target_properties(osqpstatic PROPERTIES OUTPUT_NAME osqp)
  if(ALGEBRA_DEFAULT)
    # Transitive dependency on OBJECT library does not work. See https://gitlab.kitware.com/cmake/cmake/-/issues/18682
    target_sources(osqpstatic PRIVATE $<TARGET_OBJECTS:qdldlobject>)
  endif()
  target_include_directories(
    osqpstatic PUBLIC "$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include/public;${CMAKE_CURRENT_BINARY_DIR}/include/public>"
                      "$<INSTALL_INTERFACE:$<INSTALL_PREFIX>/${CMAKE_INSTALL_INCLUDEDIR}/osqp>")

  if(MATLAB)
    target_link_libraries(osqpstatic ${Matlab_LIBRARIES})
  endif(MATLAB)
endif()

# ----------------------------------------------
# Shared Library - osqp
# ----------------------------------------------
if(OSQP_BUILD_SHARED_LIB)
  add_library(osqp SHARED ${osqplib_sources})
  if(ALGEBRA_DEFAULT)
    # Transitive dependency on OBJECT library does not work. See https://gitlab.kitware.com/cmake/cmake/-/issues/18682
    target_sources(osqp PRIVATE $<TARGET_OBJECTS:qdldlobject>)
  endif()
  target_include_directories(osqp PRIVATE ${osqplib_includes})
  target_include_directories(osqp PUBLIC "$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>"
                                         "$<INSTALL_INTERFACE:$<INSTALL_PREFIX>/${CMAKE_INSTALL_INCLUDEDIR}/osqp>")

  if(MSVC OR IS_MAC)
    # Visual Studio on Windows, and Mac OS need cuda or mkl libaries to be linked as well
    if(ALGEBRA_CUDA)
      target_link_libraries(osqp cublas cusparse)
    elseif(ALGEBRA_MKL)
      target_link_libraries(osqp $<LINK_ONLY:MKL::MKL>)
    endif()
  endif()

  # Declare that we are building the shared library to get proper symbol exports.
  # Shared library consumers should also define OSQP_SHARED_LIB to get the library
  # exports properly, so we do it for them in the CMake interface by defining it as
  # a PUBLIC compile definition.
  target_compile_definitions(osqp PRIVATE BUILDING_OSQP)
  target_compile_definitions(osqp PUBLIC  OSQP_SHARED_LIB)
endif()

# ----------------------------------------------
# Application - osqp_demo
# ----------------------------------------------
if(OSQP_BUILD_DEMO_EXE)
  add_executable(osqp_demo ${PROJECT_SOURCE_DIR}/examples/osqp_demo.c)
  #target_include_directories(osqp_demo PRIVATE ${osqplib_includes})
  target_link_libraries(osqp_demo osqpstatic)
  if(ALGEBRA_MKL)
    target_link_libraries(osqp_demo $<LINK_ONLY:MKL::MKL>)
  elseif(ALGEBRA_CUDA)
    target_link_libraries(osqp_demo cublas cusparse)
  endif()
endif()


# ----------------------------------------------
# Installation / Uninstallation
# ----------------------------------------------
install(FILES ${osqp_headers} DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}/osqp")

if(OSQP_BUILD_STATIC_LIB)
  install(
    TARGETS osqpstatic
    EXPORT ${PROJECT_NAME}
    ARCHIVE DESTINATION "${CMAKE_INSTALL_LIBDIR}"
    LIBRARY DESTINATION "${CMAKE_INSTALL_LIBDIR}"
    RUNTIME DESTINATION "${CMAKE_INSTALL_BINDIR}")
endif()

if(OSQP_BUILD_SHARED_LIB)
  install(
    TARGETS osqp
    EXPORT ${PROJECT_NAME}
    LIBRARY DESTINATION "${CMAKE_INSTALL_LIBDIR}"
    ARCHIVE DESTINATION "${CMAKE_INSTALL_LIBDIR}"
    RUNTIME DESTINATION "${CMAKE_INSTALL_BINDIR}")

  export(
    EXPORT ${PROJECT_NAME}
    FILE "${CMAKE_CURRENT_BINARY_DIR}/osqp-targets.cmake"
    NAMESPACE osqp::)

  install(
    EXPORT ${PROJECT_NAME}
    FILE osqp-targets.cmake
    NAMESPACE osqp::
    DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/osqp)

endif()

if(NOT EXISTS ${CMAKE_CURRENT_BINARY_DIR}/osqp-config.cmake)
  file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/osqp-config.cmake
       "include(\"\${CMAKE_CURRENT_LIST_DIR}/osqp-targets.cmake\")\n")
endif()

install(FILES ${CMAKE_CURRENT_BINARY_DIR}/osqp-config.cmake DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/osqp)

if(NOT TARGET uninstall)
  configure_file("${CMAKE_CURRENT_SOURCE_DIR}/configure/cmake/cmake_uninstall.cmake.in"
                 "${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake" IMMEDIATE @ONLY)

  add_custom_target(uninstall COMMAND ${CMAKE_COMMAND} -P ${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake)
endif()

# ----------------------------------------------
# Testing
# ----------------------------------------------
if(CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME)
  include(CTest)
endif()

if(CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME
   AND BUILD_TESTING
   AND OSQP_BUILD_STATIC_LIB)
  add_subdirectory(tests)
endif()
